import clr
import sys
import math
import os

# Load standard IronPython libraries
sys.path.append('C:\Program Files\IronPython 2.7\Lib')

# Try to import json module (may not be available in IronPython 2.7)
try:
    import json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        # If json is not available, we'll use a simple text-based format
        json = None

# Revit & .NET references
clr.AddReference('RevitAPI')
clr.AddReference('RevitAPIUI')
clr.AddReference('System.Windows.Forms')
clr.AddReference('System.Drawing')

from Autodesk.Revit.DB import *
from Autodesk.Revit.UI import *
from Autodesk.Revit.UI.Selection import *
from System.Windows.Forms import MessageBox, Form, Label, TextBox, Button, FormStartPosition, DialogResult, CheckBox
from System.Drawing import Point, Size, Color

# Conversion factor: feet to internal units (feet already in Revit, but this helps)
FEET_TO_INTERNAL = 1.0
INCHES_TO_FEET = 1.0 / 12.0

def feet_to_internal(feet):
    """Convert feet to Revit internal units"""
    return feet * FEET_TO_INTERNAL

def get_sorted_curves(face, sort_by_length=False):
    """
    Get perimeter curves from a face and sort them.
    
    Args:
        face: Face geometry
        sort_by_length: If True, sort by curve length (shortest first).
                       If False, sort by start point coordinates.
    
    Returns:
        List of curves sorted according to sort_by_length parameter.
    """
    edge_loops = face.GetEdgesAsCurveLoops()
    if not edge_loops or len(edge_loops) == 0:
        return []
    
    # Get the first (outer) edge loop
    outer_loop = edge_loops[0]
    curves = list(outer_loop)
    
    if sort_by_length:
        # Sort curves by their length (shortest first)
        def curve_key(crv):
            return crv.Length
        sorted_curves = sorted(curves, key=curve_key)
    else:
        # Sort curves by their start point coordinates (for consistency)
        def curve_key(crv):
            start = crv.GetEndPoint(0)
            return (start.X, start.Y, start.Z)
        sorted_curves = sorted(curves, key=curve_key)
    
    return sorted_curves

def get_point_at_parameter(curve, parameter):
    """Get point at normalized parameter (0.0 to 1.0) along curve"""
    return curve.Evaluate(parameter, True)

def get_point_at_length(curve, length_from_start):
    """
    Get point at specified length from start of curve.
    length_from_start is in feet (Revit internal units).
    """
    total_length = curve.Length
    if total_length == 0:
        return curve.GetEndPoint(0)
    
    # Calculate normalized parameter
    param = length_from_start / total_length
    param = max(0.0, min(1.0, param))  # Clamp between 0 and 1
    
    return curve.Evaluate(param, True)

def get_reversed_curve(curve):
    """Create a reversed copy of the curve"""
    if isinstance(curve, Line):
        start = curve.GetEndPoint(1)
        end = curve.GetEndPoint(0)
        return Line.CreateBound(start, end)
    elif isinstance(curve, Arc):
        # For Arc, reverse means swapping start/end angles
        center = curve.Center
        radius = curve.Radius
        normal = curve.Normal
        x_axis = curve.XDirection
        
        start_param = curve.GetEndParameter(1)
        end_param = curve.GetEndParameter(0)
        
        return Arc.Create(center, radius, start_param, end_param, x_axis, normal)
    else:
        # For other curve types, create a reversed line approximation
        start = curve.GetEndPoint(1)
        end = curve.GetEndPoint(0)
        return Line.CreateBound(start, end)

def reverse_two_shortest_edges(edge1, edge2):
    """
    Reverse both shortest edges and optionally swap their order.
    
    Args:
        edge1: First shortest edge (curve)
        edge2: Second shortest edge (curve)
    
    Returns:
        Tuple of (reversed_edge1, reversed_edge2)
    """
    reversed_edge1 = get_reversed_curve(edge1)
    reversed_edge2 = get_reversed_curve(edge2)
    return (reversed_edge1, reversed_edge2)

def create_face_based_family_instance(doc, face_ref, location_point, family_type):
    """
    Create a face-based family instance on the given face reference.
    
    Args:
        doc: Revit document
        face_ref: Reference to the face
        location_point: XYZ point for placement (projected onto face)
        family_type: FamilySymbol for the bolt family
    
    Returns:
        Created family instance or None
    """
    try:
        # Activate the family type if needed
        if not family_type.IsActive:
            family_type.Activate()
        
        # Create the family instance using face reference
        # For face-based families, NewFamilyInstance takes Reference, location, and FamilySymbol
        instance = doc.Create.NewFamilyInstance(
            face_ref,
            location_point,
            family_type
        )
        
        return instance
    except Exception as e:
        # Try with orientation vector
        try:
            instance = doc.Create.NewFamilyInstance(
                face_ref,
                location_point,
                XYZ.BasisZ,
                family_type
            )
            return instance
        except Exception as e2:
            print("Error creating family instance: {}\nTried alternative: {}".format(str(e), str(e2)))
            return None

def place_bolts_on_face(doc, face, face_ref, family_type_name, spacing_array, offset_distance, num_rows=1, row_spacing=0.0, use_reversed_curves=False):
    """
    Place face-based bolts on a face based on the Dynamo logic.
    
    Args:
        doc: Revit document
        face: Selected face geometry
        face_ref: Reference to the face
        family_type_name: Name of the family type (e.g., "EAB_Face-Based_Bolt_D1")
        spacing_array: List of spacing values in feet (converted from inches/12)
        offset_distance: Offset distance in feet from curve start
        num_rows: Number of rows of bolts to place (default: 1)
        row_spacing: Spacing between rows in feet (default: 0.0, uses distance between line1 and line2)
        use_reversed_curves: If True, use reversed curves instead of original (default: False)
    
    Returns:
        List of created family instances
    """
    instances = []
    
    try:
        # Get the family type
        collector = FilteredElementCollector(doc)
        family_symbols = collector.OfClass(FamilySymbol).WhereElementIsElementType()
        
        family_type = None
        for fs in family_symbols:
            try:
                # Get family name and symbol name safely
                family_name = ""
                symbol_name = ""
                
                if fs.Family:
                    family_name = fs.Family.Name if fs.Family.Name else ""
                if hasattr(fs, 'Name') and fs.Name:
                    symbol_name = fs.Name
                
                if not family_name and not symbol_name:
                    continue
                
                # Try different matching patterns
                full_name_1 = "{}_{}".format(family_name, symbol_name) if family_name and symbol_name else symbol_name
                full_name_2 = "{}_Face-Based_Bolt_{}".format(family_name, symbol_name) if family_name and symbol_name else symbol_name
                
                # Check if family type name matches
                search_name = family_type_name.lower()
                if (search_name in full_name_1.lower() or 
                    search_name in full_name_2.lower() or 
                    symbol_name.lower() == search_name or
                    search_name in symbol_name.lower() or
                    search_name in family_name.lower()):
                    family_type = fs
                    break
            except Exception as e:
                # Skip this family symbol if there's an error accessing its properties
                continue
        
        if family_type is None:
            MessageBox.Show(
                "Family type '{}' not found. Please ensure the family is loaded in the project.".format(family_type_name),
                "Family Type Not Found"
            )
            return instances
        
        # Get face normal at center (UV parameter 0.5, 0.5)
        try:
            face_center_uv = UV(0.5, 0.5)
            face_center = face.Evaluate(face_center_uv)
            face_normal = face.ComputeNormal(face_center_uv)
        except:
            # Fallback: use face normal from first point
            try:
                edge_loops = face.GetEdgesAsCurveLoops()
                if edge_loops and len(edge_loops) > 0:
                    first_edge = edge_loops[0][0]
                    face_center = first_edge.GetEndPoint(0)
                    face_normal = face.FaceNormal
                else:
                    MessageBox.Show("Could not determine face center.", "Error")
                    return instances
            except:
                MessageBox.Show("Could not evaluate face geometry.", "Error")
                return instances
        
        # Get perimeter curves
        # Sort by length to get shortest edges first (typically the width edges for rectangular faces)
        sorted_curves = get_sorted_curves(face, sort_by_length=True)
        if len(sorted_curves) < 2:
            MessageBox.Show("Face does not have enough perimeter curves.", "Invalid Face")
            return instances
        
        # Select the two shortest edges for point calculation
        # After sorting by length, first two curves are the shortest edges
        # Based on Dynamo code: t4 = a[0], t5 = a[1]
        t4 = sorted_curves[0]  # Shortest edge
        t5 = sorted_curves[1]  # Second shortest edge
        
        # Reverse both shortest edges using the function (for later use)
        t4_reversed, t5_reversed = reverse_two_shortest_edges(t4, t5)
        
        # Choose whether to use original or reversed curves based on user preference
        # Original (unchecked): t4 (original), t5_reversed - works correctly
        # Reversed (checked): t4_reversed, t5 (original) - swaps which edge is reversed
        # This keeps reference lines parallel and vertical in both cases
        if use_reversed_curves:
            # Swap which edge is reversed: use t4_reversed and t5 (original)
            # This maintains the same pattern as original but swaps the orientation
            curves1 = t4_reversed  # Reversed shortest edge
            curves2 = t5  # Original second shortest edge (not reversed)
        else:
            # Original logic: first edge original, second edge reversed
            curves1 = t4  # Original shortest edge
            curves2 = t5_reversed  # Reversed second shortest edge
        
        # Get points at specified length along the SHORTEST edges (t12 in Dynamo)
        # These points will be on the shortest edges
        point1 = get_point_at_length(curves1, offset_distance)  # Point on first edge
        
        # Get point on second edge
        point2 = get_point_at_length(curves2, offset_distance)  # Point on second edge
        
        # Create line between points (line1 in Dynamo)
        # This line should be vertical/parallel in both cases
        line1 = Line.CreateBound(point1, point2)
        
        # Get points for second line (for second row of bolts)
        # For line2, we reverse curves1 and get the opposite of curves2
        # This ensures line1 and line2 are parallel and don't cross
        if use_reversed_curves:
            # For reversed option: reverse t4_reversed = t4, and reverse t5 = t5_reversed
            # This swaps back to the opposite orientation for line2
            curve2 = get_reversed_curve(curves1)  # Reverse t4_reversed = t4 (original)
            curve3 = get_reversed_curve(curves2)  # Reverse t5 = t5_reversed
        else:
            # Original logic: reverse first edge for second line
            curve2 = t4_reversed  # Reversed shortest edge
            curve3 = get_reversed_curve(curves2)  # Reverse t5_reversed back = t5 (original)
        
        point3 = get_point_at_length(curve2, offset_distance)
        point4 = get_point_at_length(curve3, offset_distance)
        
        # Create second line (line2 in Dynamo)
        line2 = Line.CreateBound(point3, point4)
        
        # Store reference lines (t13 = [line1, line2] in Dynamo)
        reference_lines = [line1, line2]
        
        # Calculate bolt positions along the spacing array
        # spacing_array contains cumulative or incremental distances (in feet)
        # Based on Dynamo: spacing values are in inches/12, so already in feet
        
        # Calculate row lines based on number of rows
        row_lines = []
        line1_start = line1.GetEndPoint(0)
        line1_end = line1.GetEndPoint(1)
        line2_start = line2.GetEndPoint(0)
        line2_end = line2.GetEndPoint(1)
        
        # Calculate direction vector from line1 to line2
        row_dir_start = (line2_start - line1_start).Normalize() if (line2_start - line1_start).GetLength() > 0.001 else XYZ.BasisX
        row_dir_end = (line2_end - line1_end).Normalize() if (line2_end - line1_end).GetLength() > 0.001 else XYZ.BasisX
        
        # Calculate total distance between line1 and line2
        total_distance = (line2_start - line1_start).GetLength()
        
        if num_rows <= 1:
            # Single row: use line1 only
            row_lines = [line1]
        elif num_rows == 2:
            # Two rows: use line1 and line2
            row_lines = [line1, line2]
        else:
            # Multiple rows: create rows between line1 and line2
            if row_spacing > 0.0 and total_distance > 0.001:
                # Use specified row spacing (in feet)
                for i in range(num_rows):
                    # Calculate distance from line1
                    distance_from_line1 = i * row_spacing
                    if distance_from_line1 > total_distance:
                        break  # Don't go beyond line2
                    
                    # Interpolate position between line1 and line2
                    t = distance_from_line1 / total_distance if total_distance > 0.001 else 0.0
                    t = min(1.0, t)  # Clamp to 1.0
                    
                    start_point = line1_start + row_dir_start * distance_from_line1
                    end_point = line1_end + row_dir_end * distance_from_line1
                    row_line = Line.CreateBound(start_point, end_point)
                    row_lines.append(row_line)
            else:
                # Distribute evenly between line1 and line2
                for i in range(num_rows):
                    t = float(i) / (num_rows - 1) if num_rows > 1 else 0.0
                    start_point = line1_start + (line2_start - line1_start) * t
                    end_point = line1_end + (line2_end - line1_end) * t
                    row_line = Line.CreateBound(start_point, end_point)
                    row_lines.append(row_line)
        
        # Place bolts along each row
        for row_line in row_lines:
            line_length = row_line.Length
            line_dir = (row_line.GetEndPoint(1) - row_line.GetEndPoint(0)).Normalize()
            
            # Cumulative distance along the line
            current_distance = 0.0
            
            for spacing in spacing_array:
                if current_distance >= line_length:
                    break  # Don't go beyond line length
                
                # Calculate position along the row line
                bolt_position = row_line.GetEndPoint(0) + line_dir * current_distance
                
                # Project point onto face to ensure it's on the surface
                try:
                    instance = create_face_based_family_instance(
                        doc, face_ref, bolt_position, family_type
                    )
                    if instance:
                        instances.append(instance)
                except Exception as e:
                    print("Error placing bolt at distance {}: {}".format(current_distance, str(e)))
                
                # Move to next position (add spacing)
                current_distance += spacing
        
        return instances
        
    except Exception as e:
        import traceback
        error_msg = "Error placing bolts: {}\n\nTraceback:\n{}".format(str(e), traceback.format_exc())
        MessageBox.Show(error_msg, "Error")
        return instances

def get_preferences_file_path():
    """Get the path to the preferences JSON file"""
    try:
        # Try to save in user's home directory
        home = os.path.expanduser('~')
        prefs_dir = os.path.join(home, 'pyRebar')
        if not os.path.exists(prefs_dir):
            os.makedirs(prefs_dir)
        return os.path.join(prefs_dir, 'bolt_placement_preferences.json')
    except:
        # Fallback: save next to the script
        script_dir = os.path.dirname(os.path.abspath(__file__))
        return os.path.join(script_dir, 'bolt_placement_preferences.json')

def load_preferences():
    """Load preferences from JSON file"""
    if json is None:
        return None
    
    try:
        prefs_path = get_preferences_file_path()
        if os.path.isfile(prefs_path):
            with open(prefs_path, 'r') as f:
                prefs = json.load(f)
                return prefs
    except Exception as e:
        print("Error loading preferences: {}".format(str(e)))
    return None

def save_preferences(family_type_name, spacing_values, offset_distance, num_rows, row_spacing, use_reversed_curves):
    """Save preferences to JSON file"""
    if json is None:
        return  # Skip saving if json is not available
    
    try:
        prefs = {
            'family_type_name': family_type_name,
            'spacing_values': spacing_values,
            'offset_distance': offset_distance,
            'num_rows': num_rows,
            'row_spacing': row_spacing,
            'use_reversed_curves': use_reversed_curves
        }
        prefs_path = get_preferences_file_path()
        with open(prefs_path, 'w') as f:
            json.dump(prefs, f, indent=4)
    except Exception as e:
        print("Error saving preferences: {}".format(str(e)))

class BoltPlacementForm(Form):
    """Form for configuring bolt placement parameters"""
    def __init__(self):
        self.Text = "Place Face-Based Bolts"
        self.Width = 450
        self.Height = 490  # Increased height for checkbox field
        self.StartPosition = FormStartPosition.CenterScreen
        
        # Load previous preferences or use defaults
        prefs = load_preferences()
        if prefs:
            self.family_type_name = prefs.get('family_type_name', "EAB_Face-Based_Bolt_D1")
            self.spacing_values = prefs.get('spacing_values', "2, 5, 5, 5")
            self.offset_distance = prefs.get('offset_distance', 0.0)
            self.num_rows = prefs.get('num_rows', 1)
            self.row_spacing = prefs.get('row_spacing', 0.0)
            self.use_reversed_curves = prefs.get('use_reversed_curves', False)
        else:
            # Default values
            self.family_type_name = "EAB_Face-Based_Bolt_D1"
            self.spacing_values = "2, 5, 5, 5"
            self.offset_distance = 0.0  # in inches
            self.num_rows = 1  # Number of rows
            self.row_spacing = 0.0  # Row spacing in inches (0 = auto/evenly spaced)
            self.use_reversed_curves = False  # Use original curves by default
        
        # Family type label and input
        lbl_family = Label()
        lbl_family.Text = "Family Type Name:"
        lbl_family.Location = Point(10, 15)
        lbl_family.Size = Size(150, 20)
        self.Controls.Add(lbl_family)
        
        self.txt_family = TextBox()
        self.txt_family.Text = self.family_type_name
        self.txt_family.Location = Point(10, 35)
        self.txt_family.Size = Size(400, 22)
        self.Controls.Add(self.txt_family)
        
        # Spacing values label and input
        lbl_spacing = Label()
        lbl_spacing.Text = "Spacing (inches, comma-separated):"
        lbl_spacing.Location = Point(10, 70)
        lbl_spacing.Size = Size(250, 20)
        self.Controls.Add(lbl_spacing)
        
        self.txt_spacing = TextBox()
        self.txt_spacing.Text = self.spacing_values
        self.txt_spacing.Location = Point(10, 90)
        self.txt_spacing.Size = Size(400, 22)
        self.Controls.Add(self.txt_spacing)
        
        # Offset distance label and input
        lbl_offset = Label()
        lbl_offset.Text = "Offset from edge (inches):"
        lbl_offset.Location = Point(10, 125)
        lbl_offset.Size = Size(200, 20)
        self.Controls.Add(lbl_offset)
        
        self.txt_offset = TextBox()
        self.txt_offset.Text = str(self.offset_distance)
        self.txt_offset.Location = Point(10, 145)
        self.txt_offset.Size = Size(150, 22)
        self.Controls.Add(self.txt_offset)
        
        # Number of rows label and input
        lbl_rows = Label()
        lbl_rows.Text = "Number of rows:"
        lbl_rows.Location = Point(10, 175)
        lbl_rows.Size = Size(200, 20)
        self.Controls.Add(lbl_rows)
        
        self.txt_rows = TextBox()
        self.txt_rows.Text = str(self.num_rows)
        self.txt_rows.Location = Point(10, 195)
        self.txt_rows.Size = Size(150, 22)
        self.Controls.Add(self.txt_rows)
        
        # Row spacing label and input
        lbl_row_spacing = Label()
        lbl_row_spacing.Text = "Row spacing (inches, 0=evenly):"
        lbl_row_spacing.Location = Point(10, 225)
        lbl_row_spacing.Size = Size(250, 20)
        self.Controls.Add(lbl_row_spacing)
        
        self.txt_row_spacing = TextBox()
        self.txt_row_spacing.Text = str(self.row_spacing)
        self.txt_row_spacing.Location = Point(10, 245)
        self.txt_row_spacing.Size = Size(150, 22)
        self.Controls.Add(self.txt_row_spacing)
        
        # Use reversed curves checkbox
        self.chk_reversed = CheckBox()
        self.chk_reversed.Text = "Use reversed curves"
        self.chk_reversed.Location = Point(10, 275)
        self.chk_reversed.Size = Size(300, 20)
        self.chk_reversed.Checked = self.use_reversed_curves
        self.Controls.Add(self.chk_reversed)
        
        # Info label
        lbl_info = Label()
        lbl_info.Text = "Note: Select a face in Revit after clicking OK"
        lbl_info.Location = Point(10, 300)
        lbl_info.Size = Size(400, 40)
        lbl_info.ForeColor = Color.DarkGray
        self.Controls.Add(lbl_info)
        
        # OK button
        self.btn_ok = Button()
        self.btn_ok.Text = "OK"
        self.btn_ok.Location = Point(240, 365)
        self.btn_ok.Size = Size(80, 30)
        self.btn_ok.Click += self.on_ok
        self.Controls.Add(self.btn_ok)
        
        # Cancel button
        self.btn_cancel = Button()
        self.btn_cancel.Text = "Cancel"
        self.btn_cancel.Location = Point(330, 365)
        self.btn_cancel.Size = Size(80, 30)
        self.btn_cancel.Click += self.on_cancel
        self.Controls.Add(self.btn_cancel)
    
    def on_ok(self, sender, args):
        self.family_type_name = self.txt_family.Text.strip()
        self.spacing_values = self.txt_spacing.Text.strip()
        try:
            # Input is in inches, store as inches
            self.offset_distance = float(self.txt_offset.Text)
        except:
            MessageBox.Show("Invalid offset distance. Using default value of 0.0 inches.", "Warning")
            self.offset_distance = 0.0
        
        try:
            # Number of rows (must be at least 1)
            self.num_rows = int(self.txt_rows.Text)
            if self.num_rows < 1:
                self.num_rows = 1
        except:
            MessageBox.Show("Invalid number of rows. Using default value of 1.", "Warning")
            self.num_rows = 1
        
        try:
            # Row spacing in inches (0 = auto/evenly spaced)
            self.row_spacing = float(self.txt_row_spacing.Text)
            if self.row_spacing < 0:
                self.row_spacing = 0.0
        except:
            MessageBox.Show("Invalid row spacing. Using default value of 0.0 (evenly spaced).", "Warning")
            self.row_spacing = 0.0
        
        # Get checkbox value for using reversed curves
        self.use_reversed_curves = self.chk_reversed.Checked
        
        # Save preferences for next use
        save_preferences(
            self.family_type_name,
            self.spacing_values,
            self.offset_distance,
            self.num_rows,
            self.row_spacing,
            self.use_reversed_curves
        )
        
        self.DialogResult = DialogResult.OK
        self.Close()
    
    def on_cancel(self, sender, args):
        self.DialogResult = DialogResult.Cancel
        self.Close()

def parse_spacing_array(spacing_string):
    """
    Parse spacing string (comma-separated inches) and convert to feet.
    Example: "2, 5, 5, 5" -> [2/12, 5/12, 5/12, 5/12]
    """
    try:
        values = [float(x.strip()) for x in spacing_string.split(',')]
        # Convert inches to feet
        return [v * INCHES_TO_FEET for v in values]
    except:
        return [2.0 * INCHES_TO_FEET, 5.0 * INCHES_TO_FEET, 5.0 * INCHES_TO_FEET, 5.0 * INCHES_TO_FEET]

def main():
    """Main function to place face-based bolts"""
    try:
        # Get Revit application and document
        uiapp = __revit__
        app = uiapp.Application
        doc = uiapp.ActiveUIDocument.Document
        uidoc = uiapp.ActiveUIDocument
        
        # Show configuration form
        form = BoltPlacementForm()
        form.ShowDialog()
        
        if form.DialogResult != DialogResult.OK:
            return
        
        # Parse spacing array (converts inches to feet)
        spacing_array = parse_spacing_array(form.spacing_values)
        # Convert offset from inches to feet
        offset_distance = form.offset_distance * INCHES_TO_FEET
        # Get number of rows and row spacing
        num_rows = form.num_rows
        # Convert row spacing from inches to feet (0 = auto/evenly spaced)
        row_spacing = form.row_spacing * INCHES_TO_FEET if form.row_spacing > 0 else 0.0
        
        # Prompt user to select a face
        MessageBox.Show(
            "Please select a face in the Revit view.\n\n" +
            "Click on a face to place bolts.",
            "Select Face"
        )
        
        # Selection filter for faces
        class FaceSelectionFilter(ISelectionFilter):
            def AllowElement(self, element):
                return True
            
            def AllowReference(self, reference, position):
                return True
        
        try:
            # Select face reference
            face_ref = uidoc.Selection.PickObject(
                ObjectType.Face,
                FaceSelectionFilter(),
                "Select a face to place bolts"
            )
            
            # Get the face geometry from the reference
            element = doc.GetElement(face_ref.ElementId)
            
            # Get geometry options
            options = Options()
            options.ComputeReferences = True
            options.DetailLevel = ViewDetailLevel.Fine
            options.IncludeNonVisibleObjects = False
            
            # Try to get face directly from reference (most reliable method)
            face = None
            try:
                geometry_object = element.GetGeometryObjectFromReference(face_ref)
                if isinstance(geometry_object, Face):
                    face = geometry_object
            except Exception as e:
                print("Direct face extraction failed: {}".format(str(e)))
            
            # If direct method failed, search through geometry
            # This is needed because sometimes the reference doesn't directly return the face
            if face is None:
                try:
                    geo_elem = element.get_Geometry(options)
                    if geo_elem:
                        for obj in geo_elem:
                            if isinstance(obj, GeometryInstance):
                                # Get transformed geometry
                                transform = obj.Transform
                                instance_geo = obj.GetInstanceGeometry()
                                if instance_geo:
                                    for geom_obj in instance_geo:
                                        if isinstance(geom_obj, Solid):
                                            for face_obj in geom_obj.Faces:
                                                try:
                                                    # Check if this face matches our reference
                                                    if face_obj.Reference:
                                                        if (face_obj.Reference.ElementId == face_ref.ElementId and
                                                            hasattr(face_ref, 'LinkElementId') == hasattr(face_obj.Reference, 'LinkElementId')):
                                                            face = face_obj
                                                            break
                                                except:
                                                    pass
                                        if face:
                                            break
                                    if face:
                                        break
                            elif isinstance(obj, Solid):
                                for face_obj in obj.Faces:
                                    try:
                                        if face_obj.Reference:
                                            if (face_obj.Reference.ElementId == face_ref.ElementId and
                                                hasattr(face_ref, 'LinkElementId') == hasattr(face_obj.Reference, 'LinkElementId')):
                                                face = face_obj
                                                break
                                    except:
                                        pass
                                if face:
                                    break
                            if face:
                                break
                except Exception as e:
                    print("Error searching geometry: {}".format(str(e)))
            
            if face is None:
                MessageBox.Show(
                    "Could not extract face geometry from reference.\n" +
                    "Please try selecting a different face or ensure the element has visible faces.",
                    "Face Extraction Error"
                )
                return
            
            # Start transaction
            t = Transaction(doc, "Place Face-Based Bolts")
            t.Start()
            
            # Place bolts
            instances = place_bolts_on_face(
                doc,
                face,
                face_ref,
                form.family_type_name,
                spacing_array,
                offset_distance,
                num_rows,
                row_spacing,
                form.use_reversed_curves
            )
            
            if instances:
                t.Commit()
                MessageBox.Show(
                    "Successfully placed {} bolt(s) on the selected face.".format(len(instances)),
                    "Success"
                )
            else:
                t.RollBack()
                MessageBox.Show(
                    "No bolts were placed. Please check the family type name and face selection.",
                    "No Bolts Placed"
                )
                
        except Exception as e:
            if 'operation was cancelled' in str(e).lower() or 'cancelled' in str(e).lower():
                pass  # User cancelled selection
            else:
                MessageBox.Show(
                    "Error during face selection: {}\n\nPlease ensure you select a valid face.".format(str(e)),
                    "Selection Error"
                )
    
    except Exception as e:
        MessageBox.Show("Unexpected error: {}".format(str(e)), "Error")

if __name__ == '__main__':
    main()

